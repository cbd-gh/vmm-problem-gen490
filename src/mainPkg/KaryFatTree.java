package mainPkg;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

public class KaryFatTree {
	
	// k-value, used to determine many of the tree's properties
	private int k;
	// number of core switches in the tree
	private int nbCoreSwitches;
	// number of switch layers in tree, currently set to 3
	private final int level = 3;
	// number of pods in tree
	private int nbPods;
	// number of hosts per pod
	private int hostsPerPod;
	// total number of hosts in tree
	private int totalHosts;
	// total server load in tree;
	private double avgLoad;
	// list of tree's core switches
	private ArrayList<Switch> coreSwitches = new ArrayList<Switch>();
	// list of tree's pods
	private ArrayList<KaryPod> pods = new ArrayList<KaryPod>();
	// list of Hosts/Servers in tree
	private ArrayList<Server> servers = new ArrayList<Server>();
	// save the starting configuration of the tree
	private ArrayList<Server> startingConfig = new ArrayList<Server>();
	// save any final state generated by the tree
	private ArrayList<FinalConfig> finalStates = new ArrayList<FinalConfig>();
	// keeps value ranges for vm and server specs
	private ValueRange specs = new ValueRange();
	// server classes to be considered during generation
	private ArrayList<ServerGroup> serverClasses = new ArrayList<ServerGroup>();
	// list of VMs in server
	private ArrayList<VirtualMachine> vmList = new ArrayList<VirtualMachine>();
	// type of network
	private String networkType;
	
	// CONSTRUCTORS
	
	/**
	 * Default Constructor
	 */
	public KaryFatTree()
	{
		k = 2;
		
		nbCoreSwitches = (int) Math.pow(k, 2);
		nbPods = 2 * k;
		
		hostsPerPod = (int) Math.pow(k, 2);
		totalHosts = 2 * k * hostsPerPod;
		
		networkType = "k-ary fat tree";
		
	}
	
	/**
	 * parametrized constructor
	 * 
	 * @param nk k-value for tree
	 */
	public KaryFatTree(int nk)
	{
		k = nk;
		
		// in 3-level k-ary tree, number of core switches is k^2
		nbCoreSwitches = (int) Math.pow(k, 2);
		nbPods = 2 * k;
		
		// hosts per pod = (k/2)^2
		hostsPerPod = (int) Math.pow(k, 2);
		// total = k * hosts per pod
		totalHosts = 2 * k * hostsPerPod;
		
	}
	
	/**
	 * Parametrized constructor for different config types
	 * 
	 * @param nsv
	 * @param type
	 */
	public KaryFatTree(int nsv, String type)
	{
		k = nsv;
		
		// in 3-level k-ary tree, number of core switches is k^2
		nbCoreSwitches = (int) Math.pow(k, 2);
		nbPods = 2 * k;
		
		// hosts per pod = (k/2)^2
		hostsPerPod = (int) Math.pow(k, 2);
		// total = k * hosts per pod
		totalHosts = 2 * k * hostsPerPod;
		
		networkType = type;
	}
	
	// GETTERS AND SETTERS
	
	/**
	 * return tree's k-value
	 * 
	 * @return k value
	 */
	public int getK()
	{
		return k;
	}
	
	/**
	 * Set tree's k-value
	 * 
	 * @param nk new k-value for tree
	 */
	public void setK(int nk)
	{
		k = nk;
	}
	
	/**
	 * get number of core switches
	 * 
	 * @return number of core switches in tree
	 */
	public int getNbCores()
	{
		return nbCoreSwitches;
	}
	
	/**
	 * set number of core switches in tree
	 * 
	 * @param ncores number of core switches in tree
	 */
	public void setNbCores(int ncores)
	{
		nbCoreSwitches = ncores;
	}
	
	/**
	 * get tree's level
	 * 
	 * @return level of tree
	 */
	public int getLevel()
	{
		return level;
	}
	
	/**
	 * get number of pods in tree
	 * 
	 * @return number of pods
	 */
	public int getNbPods()
	{
		return nbPods;
	}
	
	/**
	 * Set number of pods in tree
	 * 
	 * @param npods new number of pods in tree
	 */
	public void setNbPods(int npods)
	{
		nbPods = npods;
	}
	
	/**
	 * get number of hosts per pod
	 * 
	 * @return number of hosts per pod
	 */
	public int getHPP()
	{
		return hostsPerPod;
	}
	
	/**
	 * set number of hosts per pod
	 * 
	 * @param nhpp new nb. of hosts per pod
	 */
	public void setHPP(int nhpp)
	{
		hostsPerPod = nhpp;
	}
	
	/**
	 * get max number of hosts supported by tree
	 * 
	 * @return total number of supported hosts
	 */
	public int getTotalHosts()
	{
		return totalHosts;
	}
	
	/**
	 *set max number of supported hosts for tree
	 * 
	 * @param nth total number of hosts for tree
	 */
	public void setTotalHosts(int nth)
	{
		totalHosts = nth;
	}
	
	/**
	 * return core switch in list at stated index
	 * 
	 * @param index index of core switch to return
	 * @return core switch from list to return
	 */
	public Switch getCoreSwitch(int index)
	{
		return coreSwitches.get(index);
	}
	
	/**
	 * get total server load
	 * 
	 * @return total server load
	 */
	public double getAvgLoad()
	{
		return avgLoad;
	}
	
	/**
	 * set server's total load
	 * 
	 * @param ttl new total load for server
	 */
	public void setAvgLoad(double ttl)
	{
		avgLoad = ttl;
	}
	
	/**
	 * return pod from list by index
	 * 
	 * @param index index of pod to return
	 * @return selected pod
	 */
	public KaryPod getPod(int index)
	{
		return pods.get(index);
	}
	
	/**
	 * Add a new pod to tree
	 * 
	 * @param npod new pod to add
	 */
	public void addPod(KaryPod npod)
	{
		pods.add(npod);
	}
	
	/**
	 * return server from list by index
	 * 
	 * @param index index of server to return
	 * @return selected server
	 */
	public Server getServer(int index)
	{
		return servers.get(index);
	}
	
	/**
	 * Set master server list for tree
	 * 
	 * @param nlist new list of all the tree's servers
	 */
	public void setSVList(ArrayList<Server> nlist)
	{	
		ArrayList<Server> clist = new ArrayList<Server>();
		
		for (Server sv : nlist)
		{
			clist.add(new Server(sv));
		}
		
		servers = clist;
	}
	
	/**
	 * Get list of servers
	 * 
	 * @return server list
	 */
	public ArrayList<Server> getSVlist()
	{
		return servers;
	}
	
	/**
	 * get the tree's original configuration
	 * 
	 * @return original VM/Server arrangement
	 */
	public ArrayList<Server> getStartConfig()
	{
		return startingConfig;
	}
	
	/**
	 * set tree's starting configuration
	 * 
	 * @param stcfg list of Servers with VMs at start
	 */
	public void setStartConfig(ArrayList<Server> stcfg)
	{
		
		ArrayList<Server> clist = new ArrayList<Server>();
		
		for (Server sv : stcfg)
		{
			clist.add(new Server(sv));
		}
		
		Collections.sort(clist,Server.svNumComparator);
		
		startingConfig = clist;
	}
	
	/**
	 * Return the list final states generated
	 * 
	 * @return list of final states
	 */
	public ArrayList<FinalConfig> getFinalStates()
	{
		return finalStates;
	}
	
	/**
	 * set new list of final states
	 * 
	 * @param flist new list of final states
	 */
	public void setFinalStates(ArrayList<FinalConfig> flist)
	{
		finalStates = flist;
	}
	
	/**
	 * get a final config by index
	 * 
	 * @param ind index of final state to retrieve
	 * @return selected final state
	 */
	public FinalConfig getFinal(int ind)
	{
		return finalStates.get(ind);
	}
	
	/**
	 * add a final config to the 
	 * 
	 * @param newfinal
	 */
	public void addFinal(FinalConfig newfinal)
	{
		finalStates.add(newfinal);
	}
	
	/**
	 * Return number of final states saved
	 * 
	 * @return nb. of saved final states
	 */
	public int getNbFinal()
	{
		return finalStates.size();
	}
	
	/**
	 * return value range
	 * 
	 * @return value range object
	 */
	public ValueRange getValueRange()
	{
		return specs;
	}
	
	/**
	 * set new value range object for tree
	 * 
	 * @param nr new range of values
	 */
	public void setValueRange(ValueRange nr)
	{
		specs = nr;
	}
	
	/**
	 * get list of classes for VM generation
	 * 
	 * @return list of classes
	 */
	public ArrayList<ServerGroup> getSVclasses()
	{
		return serverClasses;
	}
	
	/**
	 * set new list of server classes
	 * 
	 * @param svc
	 */
	public void setSVclasses(ArrayList<ServerGroup> svc)
	{
		serverClasses = svc;
	}
	
	/**
	 * get number of classes for servers
	 * 
	 * @return nb. of server classes
	 */
	public int getSVCtotal()
	{
		return serverClasses.size();
	}
	
	public ServerGroup getSVclass(int ind)
	{
		return serverClasses.get(ind);
	}
	
	
	public ArrayList<VirtualMachine> getVMlist()
	{
		return vmList;
	}
	
	public void setVMlist(ArrayList<VirtualMachine> vml)
	{
		ArrayList<VirtualMachine> clist = new ArrayList<VirtualMachine>();
		
		for (VirtualMachine vm : vml)
		{
			clist.add(new VirtualMachine(vm));
		}
		
		vmList = clist;
	}
	
	public void recordVMs()
	{
		ArrayList<VirtualMachine> vml = new ArrayList<VirtualMachine>();
		
		for (Server sv : servers)
		{
			vml.addAll(sv.getVMList());
		}
		
		Collections.sort(vml, VirtualMachine.vmNameComparator);
		
		setVMlist(vml);
	}
	
	/**
	 * get number of VMs in system
	 * 
	 * @return
	 */
	public int getVMnum()
	{
		return vmList.size();
	}
	
	/**
	 * get type of structure
	 * 
	 * @return
	 */
	public String getNType()
	{
		return networkType;
	}
	
	/**
	 * set type of structure
	 * 
	 * @param ntype
	 */
	public void setNType(String ntype)
	{
		networkType = ntype;
	}
	
	/**
	 * add a server directly to system
	 * 
	 * @param nsv
	 */
	public void addServer(Server nsv)
	{
		servers.add(nsv);
	}
	
	// OTHER
	
	/**
	 * Create pods for fat tree
	 */
	public void createPods()
	{
		KaryPod temp;
		
		for (int i = 0; i < (2 * getK()); i++)
		{
			temp = new KaryPod(getK(), i + 1);
			
			temp.createSwitches();
			
			addPod(temp);
		}
		
	}
	
	/**
	 * Generate Servers based on network configuration
	 */
	public void generateServers()
	{
		if (networkType.equals("k-ary fat tree"))
			generateServersFatTree();
		else
			generateServersDefault();
	}
	
	/**
	 * Generate Servers for fat tree
	 */
	public void generateServersFatTree()
	{
		ArrayList<Server> mlist = new ArrayList<Server>();
		ArrayList<Server> temp;
		
		for (KaryPod p : pods)
		{
			temp = p.generateServers(specs);
			
			mlist.addAll(temp);
		}
		
		setSVList(mlist);
	}
	
	/**
	 * Generate servers for no network config
	 */
	public void generateServersDefault()
	{
		Random rng = new Random();
		
		int svPind;
		int svMind;
		
		int svProc;
		int svMem;
		String loc = "E1";
		
		Server temp;
		
		for (int i = 0; i < k; i++)
		{
			if (specs.isPaired())
			{
				svPind = rng.nextInt(specs.getSVPsize());
				
				svProc = specs.getSVPvalue(svPind);
				svMem = specs.getSVMvalue(svPind);
				
				temp = new Server(svProc, svMem, loc);
				
				addServer(temp);
			}
			else
			{
				svPind = rng.nextInt(specs.getSVPsize());
				svMind = rng.nextInt(specs.getSVMsize());
				
				svProc = specs.getSVPvalue(svPind);
				svMem = specs.getSVMvalue(svMind);
				
				temp = new Server(svProc, svMem, loc);
				
				addServer(temp);
			}
		}
		
	}
	
	/**
	 * create the fat tree proper
	 */
	public void generateTree()
	{
		if (networkType.equals("k-ary fat tree"))
			createPods();
		
		generateServers();
		
		Server.resetCount();
		
		record();
	}
	
	/**
	 * Save current tree configuration for later restoration
	 */
	public void record()
	{
		ArrayList<Server> clist = new ArrayList<Server>();
		
		Server temp;
		
		for (Server sv : servers)
		{
			temp = new Server(sv);
			
			clist.add(temp);
		}
		
		Collections.sort(clist, Server.svNumComparator);
		
		setStartConfig(clist);
	}
	
	/**
	 * Return server configuration to original
	 */
	public void restore()
	{
		setSVList(getStartConfig());
	}
	
	/**
	 * Move a VM from one server to another
	 * 
	 * @param s1 Origin Server
	 * @param vm index of VM in origin server
	 * @param s2 Destination server
	 * @return whether move was successful or not
	 */
	public boolean moveVM(Server s1, int vm, Server s2)
	{
		VirtualMachine mvm = s1.getVM(vm);
		
		if (!s2.canMoveIn(mvm))
			return false;
		
		mvm = s1.removeVM(vm);
		
		mvm.setHost(s2.getName());
		
		s2.addVM(mvm);
		
		return true;
	}
	
	/**
	 * create deep copy of a server list
	 * 
	 * @param orig original list to copy
	 * @return deep copy of original server list
	 */
	public static ArrayList<Server> copySVList(ArrayList<Server> orig)
	{
		ArrayList<Server> nlist = new ArrayList<Server>();
		
		Server temp;
		
		for (Server sv : orig)
		{
			temp = new Server(sv);
			
			nlist.add(temp);
		}
		
		return nlist;
	}
	
	public void printServerDetails()
	{
		System.out.println("Average Server Load: " + getAvgLoad());
		System.out.println("Server Contents: ");
		
		for (Server sv : servers)
		{
			sv.print();
		}
	}
	
	public void printFinalConfigs()
	{
		System.out.println("FINAL CONFIGURATIONS:");
		
		if (finalStates.size() == 0)
			System.out.println("NONE");
		else
		{
			for (FinalConfig fc : finalStates)
			{
				System.out.println("FINAL STATE TYPE: " + fc.getType());
				
				if (fc.getDowngraded())
					System.out.println("SCENARIO HAS BEEN DOWNGRADED");
				
				for (Server sv : fc.getServers())
				{
					sv.print();
				}
			}
		}
	}
	
	/**
	 * Calculate average server load
	 * 
	 * @return average server load
	 */
	public double calculateLoad()
	{
		double Tload = 0;
		
		for (Server sv : servers)
		{
			Tload += sv.getLoad();
		}
		
		double Aload = Tload / servers.size();
		
		setAvgLoad(Aload);
		
		return Aload;
	}
	
	/**
	 * populate servers with minimum target load
	 * 
	 * @param targetLoad minimum load for each server
	 */
	public void populateServers(double targetLoad)
	{	
		for (Server sv : servers)
		{
			sv.populate(targetLoad);
			
			calculateLoad();
		}
		
		record();
	}
	
	/**
	 * populate servers according to recorded server classes
	 */
	public void populateServers()
	{
		if (serverClasses.size() == 0)
			return;
		
		// sort classes in ascending order of max load
		Collections.sort(serverClasses, ServerGroup.sgLoadComparator);
		
		Random rng = new Random();
		double minLoad = 0;
		
		ArrayList<Server> popList = new ArrayList<Server>();
		
		Server temp;
		int tindex;
		
		int removing;
		
		double cProp;
		double cMaxLoad;
		
		int total = servers.size();
		
		for (int i = 0; i < serverClasses.size(); i++)
		{
			
			if (i == (serverClasses.size() - 1))
			{
				// if this is the last class
				cMaxLoad = serverClasses.get(i).getMLoad();
				
				for (Server sv : servers)
				{
					sv.populate(minLoad, cMaxLoad, specs);
				}
				
				popList.addAll(servers);
			}
			else
			{
				// normal execution
				cProp = serverClasses.get(i).getProp();
				cMaxLoad = serverClasses.get(i).getMLoad();
				
				removing = (int) (total * cProp);
				
				System.out.println("removing " + removing + " servers");
				
				for (int j = 0; j < removing; j++)
				{
					tindex = rng.nextInt(servers.size());
					
					temp = servers.remove(tindex);
					
					temp.populate(minLoad, cMaxLoad, specs);
					
					popList.add(temp);
				}
				
				minLoad = cMaxLoad;
			}
		}
		
		Collections.sort(popList, Server.svNumComparator);
		
		// set populated list as server list
		setSVList(popList);
		
		setVMnames();
		
		calculateLoad();
		
		recordVMs();
		
		record();
	}
	
	public void populateServers2()
	{
		if (serverClasses.isEmpty())
			return;
		
		Collections.sort(serverClasses, ServerGroup.sgLoadComparator);
		
		Random rng = new Random();
		
		// starting minLoad
		double minLoad = 0;
		
		ArrayList<Server> popList = new ArrayList<Server>();
		
		Server temp;
		int tindex;
		
		int removing;
		
		double cProp;
		double cMaxLoad;
		
		int total = servers.size();
		
		for (int i = 0; i < serverClasses.size(); i++)
		{
			
			if (i == (serverClasses.size() - 1))
			{
				// if this is the last class
				cMaxLoad = serverClasses.get(i).getMLoad();
				
				for (Server sv : servers)
				{
					sv.populate2(minLoad, cMaxLoad, specs);
				}
				
				popList.addAll(servers);
			}
			else
			{
				// normal execution
				cProp = serverClasses.get(i).getProp();
				cMaxLoad = serverClasses.get(i).getMLoad();
				
				double rangeL = cMaxLoad - minLoad;
				double ran;
				double specMin;
				
				removing = (int) (total * cProp);
				
				//System.out.println("removing " + removing + " servers");
				
				for (int j = 0; j < removing; j++)
				{
					tindex = rng.nextInt(servers.size());
					
					ran = rng.nextDouble();
					specMin = (ran * rangeL) + minLoad;
					
					temp = servers.remove(tindex);
					
					temp.populate2(specMin, cMaxLoad, specs);
					
					popList.add(temp);
				}
				
				minLoad = cMaxLoad;
			}
		}
		
		Collections.sort(popList, Server.svNumComparator);
		
		// set populated list as server list
		setSVList(popList);
		
		setVMnames();
		
		calculateLoad();
		
		recordVMs();
		
		record();
	}
	
	/**
	 * randomly move VM's from one server to another
	 * 
	 * @param shufflePct load of VMs to leave on a given server
	 */
	public void shuffle(double shufflePct)
	{
		Random rng = new Random();
		
		// tagging VMs that will be moved during the shuffling process
		for (Server sv : servers)
		{
			double svLoad = sv.getLoad();
			
			double remLoad;
			
			Server scopy;
			
			// if server load exceeds percentage that should stay during shuffling process
			if (svLoad > shufflePct)
			{
				// deep copy of current server
				scopy = new Server(sv);
				
				// load of server copy
				remLoad = scopy.getLoad();
				
				int ind;
				VirtualMachine removed;
				String rmName;
				
				while (remLoad > shufflePct)
				{
					//choose random VM from copy and remove it
					ind = scopy.randomVM();
					removed = scopy.removeVM(ind);
					// get it's name (VM names are unique)
					rmName = removed.getName();
					
					// find VM in real server and tag it so it will be shuffled
					sv.getVM(rmName).setShuffle(true);
					System.out.println("Tagged: " + rmName + ".");
					
					// update copy load
					remLoad = scopy.getLoad();
				}
			}
		}
		// tagging complete
		// now: moving VMs
		
		// for each server in tree
		for (int i = 0; i < servers.size(); i++)
		{
			Server sv = servers.get(i);
			
			Server scopy = new Server(sv);
			
			// get list of server's VMs
			ArrayList<VirtualMachine> vml = scopy.getVMList();
			
			// if no VMs, move to next Server
			if (vml.size() == 0)
				continue;
			
			// for each VM in server
			for (VirtualMachine vc : vml)
			{
				// if it's marked as shuffle
				if (vc.getShuffle())
				{
					String nm = vc.getName();
					VirtualMachine moved = sv.getVM(nm);
					
					int indVM = sv.getVMList().indexOf(moved);
					
					// try to move VM to different server. give up after given nb. of tries.
					for (int j = 0; j < 20; j++)
					{
						// index of potential destination server
						int dest = rng.nextInt(servers.size());
						
						Server svd = servers.get(dest);
						
						// if destination is not same as origin
						if (dest != i)
						{
							
							if (moveVM(sv, indVM, svd))
							{
								System.out.println("Moved " + moved.getName() + " from " +
							sv.getName() + " to " + svd.getName());
								// if move is successful, set shuffle to false and stop searching
								moved.setShuffle(false);
								break;
							}
						}
					}
					
					// give up on shuffling if not moved
					moved.setShuffle(false);
				}
			}
		}
	}
	
	/**
	 * second attempt at shuffle
	 * 
	 * @param shufflePct
	 */
	public void shuffle2(double shufflePct)
	{
		ArrayList<VirtualMachine> vms = new ArrayList<VirtualMachine>();
		
		// build VM list
		for (Server sv : servers)
		{
			for (VirtualMachine vm : sv.getVMList())
			{
				vm.setShuffle(false);
				vms.add(vm);
			}
		}
		
		//System.out.println("Total VMs: " + vms.size());
		
		// get number of VMs to be shuffled
		int shuffleNb = (int) (shufflePct * vms.size());
		
		//System.out.println("Shuffle Number: " + shuffleNb);
		
		if (shuffleNb > 0)
		{
			// get random permutation
			Collections.shuffle(vms);
		
			VirtualMachine vmCurr;
			
			//for each VM to be shuffled
			for (int i = 0; i < shuffleNb; i++)
			{
				vmCurr = vms.get(i);
				vmCurr.setShuffle(true);
			
				String hostSV = vmCurr.getHost(); //get name of host sv
				
				for (Server svo : servers)
				{
					if (svo.getName().equals(hostSV)) // find host
					{
						// random permutation of indices in server list
						
						ArrayList<Integer> sIndices = new ArrayList<Integer>();
						
						for (int aa = 0; aa < servers.size(); aa++)
						{
							sIndices.add(aa);
						}
						
						Collections.shuffle(sIndices);
						
						for (int j = 0; j < sIndices.size(); j++) // search for a destination
						{
							Server svd = servers.get(j);
							
							if (!svd.getName().equals(svo.getName())) // not same as source
							{
								int ind = svo.getVMindex(vmCurr.getName()); // get index of VM
								
								if (ind != -1 && moveVM(svo, ind, svd)) //if it moves, terminate search
								{
									break;
								}
							}
						}
						
						break; //terminate search
					}
				}
			}
		
		}
	}
	
	/**
	 * Redistribute VMs according to the "Fail" scenario:
	 * 
	 * Close a random amount of servers and redistribute VMs to other servers
	 * 
	 * @param nbOut number of servers to shut down
	 */
	public void fail(int nbOut)
	{
		restore();
		
		ArrayList<Integer> failList = new ArrayList<Integer>();
		
		Random rng = new Random();
		
		boolean downgrade = false;
		
		// select servers that will be emptied
		for (int i = 0; i < nbOut;)
		{
			int fServ = rng.nextInt(servers.size());
			
			if (!failList.contains(fServ))
			{
				failList.add(fServ);
				i++;
			}
		}
		
		// for each server to be closed
		for (Integer ind : failList)
		{
			Server osv = servers.get(ind);
			Server dsv;
			
			int dest;
			
			int moved;
			
			int failedMoves = 0;
			
			// while the server hasn't been emptied
			while (osv.getNbVMs() != 0)
			{
				
				// random server as destination
				dest = rng.nextInt(servers.size());
				
				// if destination is not part of servers to shut down
				if (!failList.contains(dest))
				{
					dsv = servers.get(dest);
					
					moved = rng.nextInt(osv.getNbVMs());
					
					if (moveVM(osv, moved, dsv))
						failedMoves = 0;
					else
						failedMoves++;
				}
				
				// if a move fails to occur for a given number of iterations
				if (failedMoves > 100)
				{
					downgrade = true;
					break;
				}
			}
		}
		
		FinalConfig conf = new FinalConfig("FAIL-" + nbOut, servers);
		
		conf.setDowngraded(downgrade);
		
		addFinal(conf);
	}
	
	/**
	 * Second attempt at fail scenario, more robust but deterministic scenario
	 * 
	 * @param nbOut 
	 */
	public void fail2(int nbOut)
	{
		
		if (nbOut > servers.size())
			return;
		
		ArrayList<Server> sLive = new ArrayList<Server>();
		ArrayList<Server> sFail = new ArrayList<Server>();
		Server temp;
		
		for (Server sv : servers)
		{
			temp = new Server(sv);
			
			sLive.add(temp);
		}
		
		// randomly permute server set
		Collections.shuffle(sLive);
		
		// add random number of servers to fail set
		for (int i = 0; i < nbOut; i++)
		{
			temp = sLive.remove(0);
			
			sFail.add(temp);
		}
		
		// sort servers in ascending order of load
		Collections.sort(sFail, Server.svLoadComparator);
		
		boolean downgrade = false;
		
		for (Server sv : sFail)
		{
			// sort servers in live list in ascending order
			Collections.sort(sLive, Server.svLoadComparator);
			
			// sort vms in descending order of size
			Collections.sort(sv.getVMList(), VirtualMachine.vmSize2Comparator);
			
			int numVMs = sv.getVMList().size();
			
			int i2 = 0;
			
			for (int i = 0; i < numVMs; i++)
			{
				
				boolean hasMoved = false;
				
				for (Server svd : sLive)
				{
					if (moveVM(sv, i2, svd))
					{
						hasMoved = true;
						break; // terminate search, move on to next
					}
					
				}
				
				if (!hasMoved)
					i2++;
			}
			
			// all options exausted, server is not empty
			if (sv.getNbVMs() != 0)
				downgrade = true;
		}
		
		ArrayList<Server> sNew = new ArrayList<Server>();
		
		// add lists to new output list
		sNew.addAll(sLive);
		sNew.addAll(sFail);
		
		Collections.sort(sNew, Server.svNumComparator);
		
		// record results
		FinalConfig failConf = new FinalConfig("FAIL-" + nbOut, sNew);
		
		failConf.setDowngraded(downgrade);
		
		addFinal(failConf);
		
		restore();
	}
	
	/**
	 * all server's whose load fall under low threshold will be emptied, servers are filled up to
	 * upper threshold
	 * 
	 * @param lowThresh servers whose load is under this value will be emptied
	 * @param highThresh servers will not be filled past this load value
	 */
	public void consolidate(double lowThresh, double highThresh)
	{
		restore();
		
		// list holding empty servers
		ArrayList<Server> emptySV = new ArrayList<Server>();
		
		// list of servers below lower threshold
		ArrayList<Server> belowLT = new ArrayList<Server>();
		
		// list of servers above lower threshold
		ArrayList<Server> filledSV = new ArrayList<Server>();
		
		Random rng = new Random();
		
		boolean downgraded = false;
		
		// sort servers by load
		for (Server sv : servers)
		{
			// if server is empty, put in empty list
			//else, if below lower thresh, put in to empty list
			// else put in filled list
			
			if (sv.getLoad() == 0)
				emptySV.add(sv);
			else if (sv.getLoad() < lowThresh)
				belowLT.add(sv);
			else
				filledSV.add(sv);
		}
		
		// origin server
		Server svo;
		// destination server
		Server svd;
		// vm to move
		int movedVM;
		
		boolean moveMade;
		
		// counter goes up if no moves are made in a cycle
		int noMoveCount = 0;
		
		// while sort list contains more than one element
		while (belowLT.size() > 0)
		{
			Collections.sort(belowLT, Server.svLoadComparator);
			
			moveMade = false;
			
			// there is more than 1 server in the list
			if (belowLT.size() > 1)
			{
				// try to move a VM from the smallest load server to another
				for (int i = (belowLT.size() - 1); i > 0; i--)
				{
					svo = belowLT.get(0);
				
					svd = belowLT.get(i);
				
					// random VM from origin
					movedVM = rng.nextInt(svo.getNbVMs());
				
					// if move is successful
					if (moveVM(svo, movedVM, svd))
					{
						moveMade = true;
						
						noMoveCount = 0;
						
						Server removed;
						
						// if origin has been emptied
						if (svo.getNbVMs() == 0)
						{
							// remove from sort list
							removed = belowLT.remove(0);
							
							// add to empties
							emptySV.add(removed);
							
							i -= 1;
						}
						
						// if destination load exceeds minimum threshold
						if (svd.getLoad() > lowThresh)
						{
							// remove from sort list
							removed = belowLT.remove(i);
							
							filledSV.add(removed);
						}
						
						break;
					}
				}
			}
			
			if (!moveMade)
			{
				// sort filled list by load
				Collections.sort(filledSV, Server.svLoadComparator);
				
				svo = belowLT.get(0);
				
				movedVM = rng.nextInt(svo.getNbVMs());
				
				for (int i = 0; i < filledSV.size(); i++)
				{
					svd = filledSV.get(i);
					
					if (moveVM(svo, movedVM, svd))
					{
						moveMade = true;
						
						noMoveCount = 0;
						
						Server removed;
						
						// emptied source server
						if (svo.getNbVMs() == 0)
						{
							removed = belowLT.remove(0);
							
							emptySV.add(removed);
						}
						
						break;
					}
				}
			}
		
			
			if (!moveMade)
				noMoveCount++;
			
			if (noMoveCount > 100)
			{
				downgraded = true;
				break;
			}
		}
		
		Collections.sort(servers, Server.svNumComparator);
		
		calculateLoad();
		
		FinalConfig conf = new FinalConfig("CONS-" + lowThresh + "-" + highThresh, servers);
		
		conf.setDowngraded(downgraded);
		
		addFinal(conf);
	}
	
	/**
	 * Second attempt at consolidate scenario
	 * 
	 * @param minLoad
	 * @param maxLoad
	 */
	public void consolidate2(double minLoad, double maxLoad)
	{
		
		// sorting lists
		ArrayList<Server> sCons = new ArrayList<Server>();
		ArrayList<Server> sToEmpty = new ArrayList<Server>();
		ArrayList<Server> sEmptied = new ArrayList<Server>();
		//will be used later
		ArrayList<Server> sDowngraded = new ArrayList<Server>();
		
		
		// sorting servers
		for (Server sv : servers)
		{	
			if (sv.getNbVMs() == 0)
			{	
				sEmptied.add(sv);
			}
			else
			{	
				// check server loads are below minimum and above maximum
				boolean clearMax = sv.clearThresh(maxLoad, true);
				boolean clearMin = sv.clearThresh(minLoad, false);
				
				if (clearMax && clearMin)
					sCons.add(sv);
				else
					sToEmpty.add(sv);
			}
		}
		
		while (!sToEmpty.isEmpty())
		{
			// sort by load, ascending order
			Collections.sort(sToEmpty, Server.svLoadComparator);
			
			// get first element in list
			Server svo = sToEmpty.get(0);
			
			boolean nomove = true;
			
			// check if server clears thresholds to be moved to consol
			boolean clearMin = svo.clearThresh(minLoad, false);
			boolean clearMax = svo.clearThresh(maxLoad, true);
			
			// server has no VMs left
			if (svo.getNbVMs() == 0)
			{
				// remove server from list
				svo = sToEmpty.remove(0);
				// add to emptied
				sEmptied.add(svo);
			}
			else if (clearMin && clearMax) // server can be moved to sCons
			{
				svo = sToEmpty.remove(0);
				
				sCons.add(svo);
			}
			else // vm operation must be conducted
			{
				// sort sCons in ascending order of load
				Collections.sort(sCons, Server.svLoadComparator);
				
				int consServ = sCons.size();
				
				int ind = 0;
				
				Server svd;
				
				// check in consolidated list for move
				while (nomove && (ind < consServ))
				{
					svd = sCons.get(ind);
					
					// sort VMs in descending order of size
					Collections.sort(svo.getVMList(), VirtualMachine.vmSize2Comparator);
					
					int vmNum = svo.getVMList().size();
					
					int vmi = 0;
					int vmi2 = 0;
					
					VirtualMachine currVM;
					
					while (vmi < vmNum)
					{
						currVM = svo.getVM(vmi2);
						
						// vm can be moved without exceeding threshold
						if (svd.canMoveIn(currVM) && svd.clearThreshAdd(maxLoad, true, currVM))
						{
							moveVM(svo, vmi2, svd);
							
							nomove = false;
							
							// dont increment second index, next one will be in same position
						}
						else
						{
							// increment second index
							vmi2++;
						}
						
						// increment index
						vmi++;
					}
					
					ind++;
				}
				
				int toEmpServ = sToEmpty.size();
				
				// reset index
				ind = toEmpServ - 1;
				
				// if failed to move VMs in sCons, check sToEmpty
				while (nomove && (ind > 0))
				{
					// destination server starts with largest to smallest
					svd = sToEmpty.get(ind);
					
					// sort VMs in origin server in descending order
					Collections.sort(svo.getVMList(), VirtualMachine.vmSize2Comparator);
					
					int vmNum = svo.getVMList().size();
					
					int vmi = 0;
					int vmi2 = 0;
					
					VirtualMachine currVM;
					
					while (vmi < vmNum)
					{
						currVM = svo.getVM(vmi2);
						
						if (svd.canMoveIn(currVM) && svd.clearThreshAdd(maxLoad, true, currVM))
						{
							moveVM(svo, vmi2, svd);
							
							nomove = false;
						}
						else
							vmi2++;
						
						vmi++;
					}
					
					ind--;
				}
				
				// if still failed to move
				if (nomove)
				{
					// remove from list and classify as downgraded
					svo = sToEmpty.remove(0);
					
					sDowngraded.add(svo);
				}
			}
		}
		
		ArrayList<Server> sNew = new ArrayList<Server>();
		
		sNew.addAll(sEmptied);
		sNew.addAll(sCons);
		sNew.addAll(sDowngraded);
		
		Collections.sort(sNew, Server.svNumComparator);
		
		FinalConfig consConf = new FinalConfig("CONS-" + minLoad + "-" + maxLoad, sNew);
		
		if (sDowngraded.size() > 0)
			consConf.setDowngraded(true);
		
		addFinal(consConf);
		
		restore();
	}
	
	/**
	 * unify VM names across system
	 */
	public void setVMnames()
	{
		if (servers.size() == 0)
			return;
		
		int counter = 1;
		
		String nname;
		
		for (Server sv : servers)
		{
			for (VirtualMachine vm : sv.getVMList())
			{
				nname = "VM" + counter;
				
				vm.setName(nname);
				
				counter++;
			}
		}
	}
	
	/**
	 * Clear entire tree
	 */
	public void restart()
	{
		
	}
	
	/**
	 * Set load balancing scenario
	 */
	public void loadBalance()
	{
		restore();
		
		Random rng = new Random();
		
		int nbServ = servers.size();
		
		boolean downgrade = false;
		
		// server of VM to be moved
		Server svo;
		
		// destination server
		Server svd;
		
		int movedVM;
		
		// number of iterations for load balancing
		int nbIter = nbServ * 10;
		
		ArrayList<Server> servList = new ArrayList<Server>();
		
		servList.addAll(servers);
		
		// for a number of iterations
		for (int i = 0; i < nbIter; i++)
		{
			// sort servers by load
			Collections.sort(servList, Server.svLoadComparator);
			
			svo = servList.get(nbServ - 1);
			
			svd = servList.get(0);
			
			// random vm from origin server
			movedVM = rng.nextInt(svo.getNbVMs());
			
			moveVM(svo, movedVM, svd);
		}
		
		calculateLoad();
		
		FinalConfig conf = new FinalConfig("LBAL", servers);
		
		conf.setDowngraded(downgrade);
		
		addFinal(conf);
	}
	
	/**
	 * Second attempt at load balance scenario
	 */
	public void loadBalance2()
	{
		ArrayList<Server> sAll = new ArrayList<Server>();
		
		double totalCPU = 0;
		double totalMEM = 0;
		
		for (Server s : servers)
		{
			sAll.add(s);
			
			totalCPU += s.getCPUload();
			totalMEM += s.getMEMload();
		}
		
		// get averages
		double avgCPU = (double) totalCPU / sAll.size();
		double avgMEM = (double) totalMEM / sAll.size();
		
		// set boundaries
		
		for (Server svo : sAll)
		{
			Collections.sort(svo.getVMList(), VirtualMachine.vmSize2Comparator);
			
			for (Server svd : sAll)
			{
				String oname = svo.getName();
				String dname = svd.getName();
				
				// not the same server
				if (!oname.equals(dname))
				{
					int vmNum = svo.getVMList().size();
					
					int ind1 = 0;
					int ind2 = 0;
					
					while (ind1 < vmNum)
					{
						VirtualMachine currVM = svo.getVM(ind2);
						
						boolean origClear = svo.totalGap(avgCPU, avgMEM) >
								svo.totalGapMinus(avgCPU, avgMEM, ind2);
						
						boolean destClear = svd.totalGap(avgCPU, avgMEM) >
								svd.totalGapPlus(avgCPU, avgMEM, currVM);
						
						if (origClear && destClear && svd.canMoveIn(currVM))
						{
							moveVM(svo, ind2, svd);
							
						}
						else
							ind2++;
						
						ind1++;
					}
				}
			}
		}
		
		Collections.sort(sAll, Server.svNumComparator);
		
		FinalConfig lbalConf = new FinalConfig("LBAL",sAll);
		
		addFinal(lbalConf);
		
		restore();
	}
	
	/**
	 * Shuffle by Removing all VMs from Servers and redistributing them
	 */
	public void dlShuffle()
	{
		System.out.println("Beginning Deadlock Shuffle...");
		
		boolean finished = false;
		
		ArrayList<VirtualMachine> vmHold = new ArrayList<VirtualMachine>();
		
		while (!finished)
		{
			VirtualMachine cvm;
			
			for (Server s : servers)
			{
				// if server has vms remaining
				while (s.getNbVMs() != 0)
				{
					// remove vm from sever and add it to list
					cvm = s.removeVM(0);
					vmHold.add(cvm);
				}
			}
			
			// start by adding largest VMs first
			Collections.sort(vmHold, VirtualMachine.vmSize2Comparator);
			
			int ind = 0;
			int vmTotal = vmHold.size();
			
			//for all VMs in the system
			for (int i = 0; i < vmTotal; i++)
			{
				cvm = vmHold.get(ind);
				
				Collections.shuffle(servers);
				
				int j = 0;
				boolean vmIsMoved = false;
				
				Server curr;
				
				while (j < servers.size() && !vmIsMoved)
				{
					curr = servers.get(j);
					
					//if server has space for current vm
					if (curr.canMoveIn(cvm))
					{
						// remove VM from list
						VirtualMachine added = vmHold.remove(ind);
						//set new host
						added.setHost(curr.getName());
						// add to server
						curr.addVM(added);
						// vm has been moved
						vmIsMoved = true;
					}
					
					j++;
				}
			}
			
			System.out.println("undistributed VMs: " + vmHold.size());
			
			if (vmHold.isEmpty())
				finished = true;
		}
		
		System.out.println("Deadlock Shuffle complete");
		
		// add new final config
		Collections.sort(servers, Server.svNumComparator);
		
		FinalConfig dshfConf = new FinalConfig("DSHF", servers);
		
		addFinal(dshfConf);
		
		restore();
	}
}
